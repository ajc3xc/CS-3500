/***********************************************************
 * hint.l
 ***********************************************************/
/* -- PREAMBLE  ------------------------------------------ */
%{
#include <iostream>
#include <iomanip>
#include "puckparser.tab.h"      // file generated by Bison
using namespace std;

int line_num = 1;      // to keep line numbers

// Function prototypes
void writeToken(const char* toktype);
void printToken(const string output);



%}

     /* -- OPTIONS and DEFINITIONS ----------------------- */
%option noyywrap

WHITE      [ \t]
DIGIT      [0-9]
ALPHA      [a-zA-Z]
ALPHANUM   [a-zA-Z0-9]

T_INTEGER		[+-]?{DIGIT}+
T_DECIMAL		{T_INTEGER}[.]{DIGIT}+
T_STRING	[\"][^ \n\t\r\"]*[\"]
T_IDENT	{ALPHA}{ALPHANUM}*

%%   /* -- REGULAR EXPRESSIONS ---------------------------- */

{WHITE}    ;                /* eat white space */
\n         { line_num++; }  /* count line numbers */


  /* Complex Tokens */
{T_IDENT}         { writeToken("T_IDENT"); return T_IDENT; }
{T_INTEGER}     { writeToken("T_INTEGER"); return T_INTEGER; }
{T_DECIMAL}    	{ writeToken("T_DECIMAL"); return T_DECIMAL; }
{T_STRING}    	{ writeToken("T_STRING"); return T_STRING; }

%%   /* -- EPILOGUE  -------------------------------------- */

// Purpose: prints that a token was found
void writeToken(const char* toktype)
{
  cout << "TOKEN: ";
  cout << left << setw(14) << toktype;
  cout << "LEXEME: " << yytext << endl;
}

void printToken(const string output)
{
	cout << "TOKEN: ";
	cout << left << setw(14) << output;
	cout << "LEXEME: " << yytext <<endl;
}

/*
{OP_ASSIGN}    	{ writeToken("OP_ASSIGN"); return OP_ASSIGN; }
{OP_NEG}    	{ writeToken("OP_NEG"); return OP_NEG; }
{OP_ADD}    	{ writeToken("OP_ADD"); return OP_ADD; }
{OP_RELATION}    	{ writeToken("OP_RELATION"); return OP_RELATION; }
{OP_MULT}    	{ writeToken("OP_MULT"); return OP_MULT; }
"<"|">"|"="|"#"       { writeToken("OP_RELATION"); return OP_RELATION; }
"+"|"-"|"&"|"OR"       { writeToken("OP_ADD"); return OP_ADD; }
"*"|"/"|"AND"       { writeToken("OP_MULT"); return OP_MULT; }
":="       { writeToken("OP_ASSIGN"); return OP_ASSIGN; }
{OP_NEG}       { writeToken("OP_NEG"); return OP_NEG; }
*/
/*OP_ASSIGN	":="
/***********************************************************
 * hint.l
 ***********************************************************/
/* -- PREAMBLE  ------------------------------------------ */
%{
#include <iostream>
#include <iomanip>
#include "puckparser.tab.h"      // file generated by Bison
using namespace std;

int line_num = 1;      // to keep line numbers

// Function prototype
void writeToken(const char* toktype);

%}

     /* -- OPTIONS and DEFINITIONS ----------------------- */
%option noyywrap

WHITE      [ \t]
DIGIT      [0-9]
ALPHA      [a-zA-Z]
ALPHANUM   [a-zA-Z0-9]

T_INTEGER		[+-]?{DIGIT}+
T_DECIMAL		{T_INTEGER}[.]{DIGIT}+
T_STRING	[\"][^ \n\t\r\"]*[\"]
T_IDENT	{ALPHA}{ALPHANUM}*

OP_ASSIGN	":="
OP_NEG		"~"
OP_RELATION "<"|">"|"="|"#"
OP_ADD		"+"|"-"|"&"|"OR"
OP_MULT		"*"|"/"|"AND"

%%   /* -- REGULAR EXPRESSIONS ---------------------------- */

{WHITE}    ;                /* eat white space */
\n         { line_num++; }  /* count line numbers */

 /* Keywork tokens */
";"        { writeToken("K_SC"); return K_SC; }
"("        { writeToken("K_LPAREN"); return K_LPAREN; }
")"        { writeToken("K_RPAREN"); return K_RPAREN; }
"WRITE"    { writeToken("K_WRITE"); return K_WRITE; }
"IF"    { writeToken("K_IF"); return K_IF; }
"THEN"    { writeToken("K_THEN"); return K_THEN; }
"ELSE"    { writeToken("K_ELSE"); return K_ELSE; }
"FI"    { writeToken("K_FI"); return K_FI; }
"LOOP"    { writeToken("K_LOOP"); return K_LOOP; }
"DO"    { writeToken("K_DO"); return K_DO; }
"POOL"    { writeToken("K_POOL"); return K_POOL; }

 /* Operator tokens */
{OP_ASSIGN}       { writeToken("OP_ASSIGN"); return OP_ASSIGN; }
{OP_NEG}       { writeToken("OP_NEG"); return OP_NEG; }
{OP_RELATION}       { writeToken("OP_RELATION"); return OP_RELATION; }
{OP_MULT}       { writeToken("OP_MULT"); return OP_MULT; }
{OP_ADD}       { writeToken("OP_ADD"); return OP_ADD; }


  /* Complex Tokens */
{T_IDENT}         { writeToken("T_IDENT"); return T_IDENT; }
{T_INTEGER}              { writeToken("T_INTEGER"); return T_INTEGER; }
{T_DECIMAL}    { writeToken("T_DECIMAL"); return T_DECIMAL; }
{T_STRING}    	{ writeToken("T_STRING"); return T_STRING; }

%%   /* -- EPILOGUE  -------------------------------------- */

// Purpose: prints that a token was found
void writeToken(const char* toktype)
{
  cout << "TOKEN: ";
  cout << left << setw(14) << toktype;
  cout << "LEXEME: " << yytext << endl;
}
*/